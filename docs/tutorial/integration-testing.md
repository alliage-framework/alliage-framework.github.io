---
sidebar_position: 8
---

# Integration testing

**The challenge**: Unit tests verify individual components, but they can't catch issues that occur when all parts of your application work together.

**The solution**: Integration tests that run your complete application in a controlled environment.

## Understanding Alliage's sandbox testing

Alliage provides a sandbox system that can run your entire application as a separate process for testing. This lets you test exactly what users will experience.

## Setting up integration tests

Update `integration-tests/main-scenario/index.test.ts`:

```typescript title="integration-tests/main-scenario/index.test.ts"
import { describe, it, expect, beforeAll, afterAll, vi } from "vitest";
import { Sandbox } from "@alliage/sandbox";

describe("Main scenario", () => {
  const sandbox = new Sandbox({
    scenarioPath: __dirname,
  });

  beforeAll(async () => {
    await sandbox.init();
  });

  afterAll(async () => {
    await sandbox.clear();
  });

  describe("say-hello process", () => {
    it("greets users in English", async () => {
      const dataSpy = vi.fn();
      const { process: mainProcess, waitCompletion } = sandbox.run([
        "say-hello",
        "John",
      ]);

      mainProcess.stdout?.on("data", dataSpy);
      await waitCompletion();

      expect(dataSpy).toHaveBeenCalledWith("Hello, John!");
    });

    it("greets users in French", async () => {
      const dataSpy = vi.fn();
      const { process: mainProcess, waitCompletion } = sandbox.run([
        "say-hello",
        "Jean",
        "--language=fr",
      ]);

      mainProcess.stdout?.on("data", dataSpy);
      await waitCompletion();

      expect(dataSpy).toHaveBeenCalledWith("Bonjour Jean !");
    });

    it("provides help information", async () => {
      const dataSpy = vi.fn();
      const { process: mainProcess, waitCompletion } = sandbox.run([
        "say-hello",
        "--help",
      ]);

      mainProcess.stdout?.on("data", dataSpy);
      await waitCompletion();

      // Verify help output contains expected information
      const output = dataSpy.mock.calls.map(call => call[0]).join('');
      expect(output).toContain("Your name");
      expect(output).toContain("--language");
    });
  });
});
```

**What the sandbox testing provides**:
- **Real process execution**: Spawns actual Node.js processes like production
- **Complete application stack**: Tests configuration loading, dependency injection, and service discovery
- **Isolated environment**: Each test runs with a clean application state
- **User perspective**: Tests the exact same entry points that users will use

**Understanding the test structure**:
- **`sandbox.init()`**: Prepares the testing environment
- **`sandbox.run()`**: Spawns a new process with the specified command line arguments
- **`sandbox.clear()`**: Cleans up the files generated by the sandbox
- **`mainProcess.stdout`**: Captures the actual output from the running process
- **`waitCompletion()`**: Waits for the process to finish executing

## Building and testing

Before running integration tests, you need to build the application:

```bash
yarn alliage:build
yarn test:integration
```

**Why the build step matters**: Integration tests run against the compiled JavaScript, not the TypeScript source. This ensures your tests verify the same code that runs in production.

## Understanding test scenarios

### Basic functionality tests
These verify core features work as expected:

```typescript
it("greets users in English", async () => {
  // Test default language behavior
});

it("greets users in French", async () => {
  // Test language option functionality
});
```

### Error handling tests
These verify the application handles edge cases gracefully:

```typescript
it("handles missing arguments gracefully", async () => {
  const { process: mainProcess, waitCompletion } = sandbox.run([
    "say-hello",
    // Missing required name argument
  ]);

  await waitCompletion();
  
  expect(mainProcess.exitCode).not.toBe(0);
});
```

### Configuration tests
These verify external configuration is loaded correctly:

```typescript
it("supports configured languages", async () => {
  const dataSpy = vi.fn();
  const { process: mainProcess, waitCompletion } = sandbox.run([
    "say-hello",
    "Carlos",
    "--language=es",
  ]);

  mainProcess.stdout?.on("data", dataSpy);
  await waitCompletion();

  expect(dataSpy).toHaveBeenCalledWith("¡Hola Carlos!");
});
```

## Benefits of integration testing

**Confidence in deployments**: Integration tests verify that all components work together correctly

**Real-world validation**: Tests use the same configuration and environment setup as production

**Regression detection**: Catches issues that might slip through unit tests, like configuration errors or service wiring problems

**Documentation**: Integration tests serve as executable documentation of how users interact with your application

## The complete testing strategy

You now have two levels of testing:
- **Unit tests**: Fast feedback for individual components and business logic
- **Integration tests**: Confidence that the complete system works correctly
- **Combined coverage**: Different types of bugs caught at appropriate levels

### When to use each type

**Unit tests for**:
- Business logic validation
- Edge case handling
- Component behavior in isolation
- Fast development feedback

**Integration tests for**:
- End-to-end workflows
- Configuration validation
- Service integration
- User experience verification

## Running all tests

You can run both test suites together:

```bash
# Run unit tests first (faster feedback)
yarn test:unit

# Build and run integration tests
yarn alliage:build
yarn test:integration

# Or run everything at once
yarn test
```

## Next steps

Now that you have comprehensive testing, let's explore event-driven architecture. The next step will show you how to add cross-cutting concerns like logging without modifying existing code.

**[Continue to event-driven architecture →](/docs/tutorial/event-driven-architecture)** 